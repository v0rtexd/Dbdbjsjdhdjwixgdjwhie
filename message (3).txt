local Library = loadstring(game:HttpGet("https://pastefy.app/kX0cABr4/raw"))()
local main = Library.new()

local Players = game:GetService('Players')
local Player = Players.LocalPlayer
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local UserInputService = game:GetService('UserInputService')
local Debris = game:GetService('Debris')
local RunService = game:GetService('RunService')
local TweenService = game:GetService('TweenService')
local VirtualInputService = game:GetService("VirtualInputManager") -- Added for consistency with second script's usage
local GuiService = game:GetService('GuiService') -- Added for consistency with second script's usage

local Config = {
    AutoParry = false,
    AutoSpam = false,
    LobbyAP = false,
    ParryType = "Custom",
    SpeedMultiplier = 1.1,
    LobbySpeedMultiplier = 1.1,
    ParryThreshold = 2.5,
    RandomParryAccuracyEnabled = false,
    LobbyAPRandomParryAccuracyEnabled = false,
    AutoParryKeypress = false,
    SpamParryKeypress = false,
    LobbyAPKeypress = false,
    InfinityDetection = true,
    DeathSlashDetection = true,
    TimeHoleDetection = true,
    SlashOfFuryDetection = true,
    PhantomV2Detection = true,
    AutoAbility = true,
    CooldownProtection = true,
    -- New Config flags from second script
    AutoSpamNotify = false,
    LobbyAPNotify = false,
    HotkeyParryType = false,
    HotkeyParryTypeNotify = false,
    AnimationFix = false, -- For Auto Spam's animation fix
}

local State = {
    remotes = {},
    parryKey = nil,
    activeMethod = "Remote",
    parried = false,
    trainingParried = false,
    infinity = false,
    deathSlash = false,
    timeHole = false,
    aerodynamic = false,
    aerodynamicTime = tick(),
    lastParry = 0,
    parries = 0,
    connections = {},
    closestEntity = nil,
    currentBall = nil,
    lerpRadians = 0,
    lastWarping = tick(),
    curving = tick(),
    previousVelocity = {}, -- Used in new IsCurved
    velocityHistory = {},
    curvePrediction = {},
    lastSpamCheck = 0,
    spamCooldown = 0.1,
    -- New State variables from second script
    firstParryFired = false,
    firstParryType = 'F_Key', -- Default value
    grabParry = nil, -- For the enhanced PlayParryAnimation
}

getgenv().skinChanger = false
getgenv().swordModel = ""
getgenv().swordAnimations = ""
getgenv().swordFX = ""

task.spawn(function()
    for _, Value in getgc() do
        if type(Value) == 'function' and islclosure(Value) then
            local Protos = debug.getprotos(Value)
            local Upvalues = debug.getupvalues(Value)
            local Constants = debug.getconstants(Value)
            if #Protos == 4 and #Upvalues == 24 and #Constants >= 102 then
                local c62 = Constants[62]
                local c64 = Constants[64]
                local c65 = Constants[65]
                State.remotes[debug.getupvalue(Value, 16)] = c62
                State.parryKey = debug.getupvalue(Value, 17)
                State.remotes[debug.getupvalue(Value, 18)] = c64
                State.remotes[debug.getupvalue(Value, 19)] = c65
                break
            end
        end
    end
    if not State.parryKey or next(State.remotes) == nil then
        warn("V")
        State.activeMethod = "F Key"
    else
        print("j")
    end
end)

local AutoParry = {}

function AutoParry.GetBalls()
    local balls = {}
    for _, instance in pairs(workspace.Balls:GetChildren()) do
        if instance:GetAttribute('realBall') then
            instance.CanCollide = false
            table.insert(balls, instance)
        end
    end
    return balls
end

function AutoParry.GetBall()
    for _, instance in pairs(workspace.Balls:GetChildren()) do
        if instance:GetAttribute('realBall') then
            instance.CanCollide = false
            return instance
        end
    end
end

function AutoParry.GetLobbyBalls()
    for _, instance in pairs(workspace.TrainingBalls:GetChildren()) do
        if instance:GetAttribute("realBall") then
            return instance
        end
    end
end

function AutoParry.GetClosestPlayer()
    local maxDistance = math.huge
    local foundEntity = nil
    for _, entity in pairs(workspace.Alive:GetChildren()) do
        if tostring(entity) ~= tostring(Player) and entity.PrimaryPart then
            local distance = Player:DistanceFromCharacter(entity.PrimaryPart.Position)
            if distance < maxDistance then
                maxDistance = distance
                foundEntity = entity
            end
        end
    end
    State.closestEntity = foundEntity
    return foundEntity
end

function AutoParry.LinearInterpolation(a, b, timeVolume)
    return a + (b - a) * timeVolume
end

-- New helper functions for AutoParry (from second script, adapted)
function AutoParry:GetBallProperties()
    local ball = self.GetBall()
    if not ball then
        return {
            Velocity = Vector3.zero,
            Direction = Vector3.zero,
            Distance = 0,
            Dot = 0
        }
    end
    local ballVelocity = ball.AssemblyLinearVelocity
    local ballOrigin = ball
    local ballDirection = (Player.Character.PrimaryPart.Position - ballOrigin.Position).Unit
    local ballDistance = (Player.Character.PrimaryPart.Position - ball.Position).Magnitude
    local ballDot = ballDirection:Dot(ballVelocity.Unit)
    return {
        Velocity = ballVelocity,
        Direction = ballDirection,
        Distance = ballDistance,
        Dot = ballDot
    }
end

function AutoParry:GetEntityProperties()
    self.GetClosestPlayer()
    if not State.closestEntity then
        return false
    end
    local entityVelocity = State.closestEntity.PrimaryPart.Velocity
    local entityDirection = (Player.Character.PrimaryPart.Position - State.closestEntity.PrimaryPart.Position).Unit
    local entityDistance = (Player.Character.PrimaryPart.Position - State.closestEntity.PrimaryPart.Position).Magnitude
    return {
        Velocity = entityVelocity,
        Direction = entityDirection,
        Distance = entityDistance
    }
end

function AutoParry.SpamService(properties)
    local ball = AutoParry.GetBall()
    local entity = State.closestEntity
    if not ball or not entity or not entity.PrimaryPart then
        return 0
    end

    local spamAccuracy = 0
    local velocity = ball.AssemblyLinearVelocity
    local speed = velocity.Magnitude
    local direction = (Player.Character.PrimaryPart.Position - ball.Position).Unit
    local dot = direction:Dot(velocity.Unit)
    local targetPosition = entity.PrimaryPart.Position
    local targetDistance = Player:DistanceFromCharacter(targetPosition)
    local maximumSpamDistance = properties.Ping + math.min(speed / 6, 95)

    if properties.Entity_Properties.Distance > maximumSpamDistance then
        return spamAccuracy
    end
    if properties.Ball_Properties.Distance > maximumSpamDistance then
        return spamAccuracy
    end
    if targetDistance > maximumSpamDistance then
        return spamAccuracy
    end

    local maximumSpeed = 5 - math.min(speed / 5, 5)
    local maximumDot = math.clamp(dot, -1, 0) * maximumSpeed
    spamAccuracy = maximumSpamDistance - maximumDot
    return spamAccuracy
end

-- Enhanced IsCurved logic (from second script, adapted to use State variables)
function AutoParry.IsCurved()
    local ball = AutoParry.GetBall()
    if not ball then return false end
    local zoomies = ball:FindFirstChild('zoomies')
    if not zoomies then return false end

    local ping = game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue()
    local velocity = zoomies.VectorVelocity
    local ballDirection = velocity.Unit
    local playerPos = Player.Character.PrimaryPart.Position
    local ballPos = ball.Position
    local direction = (playerPos - ballPos).Unit
    local dot = direction:Dot(ballDirection)
    local speed = velocity.Magnitude
    local speedThreshold = math.min(speed / 100, 40)
    local distance = (playerPos - ballPos).Magnitude
    local reachTime = distance / speed - (ping / 1000)

    local ballDistanceThreshold = 15 - math.min(distance / 1000, 15) + speedThreshold
    table.insert(State.previousVelocity, velocity)
    if #State.previousVelocity > 4 then
        table.remove(State.previousVelocity, 1)
    end

    if ball:FindFirstChild('AeroDynamicSlashVFX') then
        Debris:AddItem(ball.AeroDynamicSlashVFX, 0)
        State.aerodynamicTime = tick()
    end
    local runtime = workspace:FindFirstChild('Runtime')
    if runtime and runtime:FindFirstChild('Tornado') then
        if (tick() - State.aerodynamicTime) < ((runtime.Tornado:GetAttribute("TornadoTime") or 1) + 0.314159) then
            return true
        end
    end

    local enoughSpeed = speed > 160
    if enoughSpeed and reachTime > ping / 10 then
        if speed < 300 then
            ballDistanceThreshold = math.max(ballDistanceThreshold - 15, 15)
        elseif speed >= 300 and speed < 600 then
            ballDistanceThreshold = math.max(ballDistanceThreshold - 16, 16)
        elseif speed > 600 and speed < 1000 then
            ballDistanceThreshold = math.max(ballDistanceThreshold - 17, 17)
        elseif speed > 1000 and speed < 1500 then
            ballDistanceThreshold = math.max(ballDistanceThreshold - 19, 19)
        elseif speed > 1500 then
            ballDistanceThreshold = math.max(ballDistanceThreshold - 20, 20)
        end
    end
    if distance < ballDistanceThreshold then
        return false
    end

    if speed < 300 then
        if (tick() - State.curving) < (reachTime / 1.2) then
            return true
        end
    elseif speed >= 300 and speed < 450 then
        if (tick() - State.curving) < (reachTime / 1.21) then
            return true
        end
    elseif speed > 450 and speed < 600 then
        if (tick() - State.curving) < (reachTime / 1.335) then
            return true
        end
    elseif speed > 600 then
        if (tick() - State.curving) < (reachTime / 1.5) then
            return true
        end
    end

    local dotThreshold = (0.5 - ping / 1000)
    local directionDifference = (ballDirection - velocity.Unit)
    local directionSimilarity = direction:Dot(directionDifference.Unit)
    local dotDifference = dot - directionSimilarity
    if dotDifference < dotThreshold then
        return true
    end

    local clampedDot = math.clamp(dot, -1, 1)
    local radians = math.deg(math.asin(clampedDot))
    State.lerpRadians = AutoParry.LinearInterpolation(State.lerpRadians, radians, 0.8)

    if speed < 300 then
        if State.lerpRadians < 0.02 then
            State.lastWarping = tick()
        end
        if (tick() - State.lastWarping) < (reachTime / 1.19) then
            return true
        end
    else
        if State.lerpRadians < 0.018 then
            State.lastWarping = tick()
        end
        if (tick() - State.lastWarping) < (reachTime / 1.5) then
            return true
        end
    end

    if #State.previousVelocity == 4 then
        local intendedDirectionDifference = (ballDirection - State.previousVelocity[1].Unit).Unit
        local intendedDot = direction:Dot(intendedDirectionDifference)
        local intendedDotDifference = dot - intendedDot
        local intendedDirectionDifference2 = (ballDirection - State.previousVelocity[2].Unit).Unit
        local intendedDot2 = direction:Dot(intendedDirectionDifference2)
        local intendedDotDifference2 = dot - intendedDot2
        if intendedDotDifference < dotThreshold or intendedDotDifference2 < dotThreshold then
            return true
        end
    end

    local backwardsCurveDetected = false
    local backwardsAngleThreshold = 85
    local horizDirection = Vector3.new(playerPos.X - ballPos.X, 0, playerPos.Z - ballPos.Z)
    if horizDirection.Magnitude > 0 then
        horizDirection = horizDirection.Unit
    end
    local awayFromPlayer = -horizDirection
    local horizBallDir = Vector3.new(ballDirection.X, 0, ballDirection.Z)
    if horizBallDir.Magnitude > 0 then
        horizBallDir = horizBallDir.Unit
        local backwardsAngle = math.deg(math.acos(math.clamp(awayFromPlayer:Dot(horizBallDir), -1, 1)))
        if backwardsAngle < backwardsAngleThreshold then
            backwardsCurveDetected = true
        end
    end
    return (dot < dotThreshold) or backwardsCurveDetected
end

-- Enhanced PlayParryAnimation logic (from second script, adapted to use State.grabParry)
function AutoParry.PlayParryAnimation()
    local parryAnimation = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild('GrabParry')
    local currentSword = Player.Character:GetAttribute('CurrentlyEquippedSword')
    if not currentSword then
        return
    end
    if not parryAnimation then
        return
    end
    local swordData = ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(currentSword)
    if not swordData or not swordData['AnimationType'] then
        return
    end
    for _, object in pairs(ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren()) do
        if object.Name == swordData['AnimationType'] then
            if object:FindFirstChild('GrabParry') or object:FindFirstChild('Grab') then
                local swordAnimationType = 'GrabParry'
                if object:FindFirstChild('Grab') then
                    swordAnimationType = 'Grab'
                end
                parryAnimation = object[swordAnimationType]
            end
        end
    end
    State.grabParry = Player.Character.Humanoid.Animator:LoadAnimation(parryAnimation)
    State.grabParry:Play()
end

-- New function to handle first parry press (from second script)
local function updateNavigation(guiObject)
    GuiService.SelectedObject = guiObject
end

local function performFirstPress(parryType)
    if parryType == 'F_Key' then
        VirtualInputService:SendKeyEvent(true, Enum.KeyCode.F, false, nil)
    elseif parryType == 'Left_Click' then
        VirtualInputService:SendMouseButtonEvent(0, 0, 0, true, game, 0)
    elseif parryType == 'Navigation' then
        local button = Players.LocalPlayer.PlayerGui.Hotbar.Block
        updateNavigation(button)
        VirtualInputService:SendKeyEvent(true, Enum.KeyCode.Return, false, game)
        VirtualInputService:SendKeyEvent(false, Enum.KeyCode.Return, false, game)
        task.wait(0.01)
        updateNavigation(nil)
    end
end

-- Enhanced GetParryData logic (from second script, adapted)
function AutoParry.GetParryData(parryType)
    local events = {}
    local camera = workspace.CurrentCamera
    local lastInput = UserInputService:GetLastInputType()
    local vector2MouseLocation
    local isMobile = UserInputService.TouchEnabled and not UserInputService.MouseEnabled

    if lastInput == Enum.UserInputType.MouseButton1 or (Enum.UserInputType.MouseButton2 or lastInput == Enum.UserInputType.Keyboard) then
        local mouseLocation = UserInputService:GetMouseLocation()
        vector2MouseLocation = {mouseLocation.X, mouseLocation.Y}
    else
        vector2MouseLocation = {camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2}
    end

    if isMobile then
        vector2MouseLocation = {camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2}
    end

    for _, v in pairs(workspace.Alive:GetChildren()) do
        if v ~= Player.Character then
            local worldPos = v.PrimaryPart.Position
            local screenPos, isOnScreen = camera:WorldToScreenPoint(worldPos)
            events[tostring(v)] = screenPos
        end
    end

    if parryType == 'Camera' then
        return {0, camera.CFrame, events, vector2MouseLocation}
    elseif parryType == 'Backwards' then
        local backwardsDirection = camera.CFrame.LookVector * -10000
        backwardsDirection = Vector3.new(backwardsDirection.X, 0, backwardsDirection.Z)
        return {0, CFrame.new(camera.CFrame.Position, camera.CFrame.Position + backwardsDirection), events, vector2MouseLocation}
    elseif parryType == 'Straight' then
        local aimedPlayer = nil
        local closestDistance = math.huge
        local mouseVector = Vector2.new(vector2MouseLocation[1], vector2MouseLocation[2])

        for _, v in pairs(workspace.Alive:GetChildren()) do
            if v ~= Player.Character then
                local worldPos = v.PrimaryPart.Position
                local screenPos, isOnScreen = camera:WorldToScreenPoint(worldPos)

                if isOnScreen then
                    local playerScreenPos = Vector2.new(screenPos.X, screenPos.Y)
                    local distance = (mouseVector - playerScreenPos).Magnitude

                    if distance < closestDistance then
                        closestDistance = distance
                        aimedPlayer = v
                    end
                end
            end
        end

        if aimedPlayer then
            return {0, CFrame.new(Player.Character.PrimaryPart.Position, aimedPlayer.PrimaryPart.Position), events, vector2MouseLocation}
        else
            return {0, CFrame.new(Player.Character.PrimaryPart.Position, State.closestEntity.PrimaryPart.Position), events, vector2MouseLocation}
        end
    elseif parryType == 'Random' then
        return {0, CFrame.new(camera.CFrame.Position, Vector3.new(math.random(-4000, 4000), math.random(-4000, 4000), math.random(-4000, 4000))), events, vector2MouseLocation}
    elseif parryType == 'High' then
        local highDirection = camera.CFrame.UpVector * 10000
        return {0, CFrame.new(camera.CFrame.Position, camera.CFrame.Position + highDirection), events, vector2MouseLocation}
    elseif parryType == 'Left' then
        local leftDirection = camera.CFrame.RightVector * 10000
        return {0, CFrame.new(camera.CFrame.Position, camera.CFrame.Position - leftDirection), events, vector2MouseLocation}
    elseif parryType == 'Right' then
        local rightDirection = camera.CFrame.RightVector * 10000
        return {0, CFrame.new(camera.CFrame.Position, camera.CFrame.Position + rightDirection), events, vector2MouseLocation}
    elseif parryType == 'RandomTarget' then
        local candidates = {}
        for _, v in pairs(workspace.Alive:GetChildren()) do
            if v ~= Player.Character and v.PrimaryPart then
                local screenPos, isOnScreen = camera:WorldToScreenPoint(v.PrimaryPart.Position)
                if isOnScreen then
                    table.insert(candidates, {
                        character = v,
                        screenXY  = { screenPos.X, screenPos.Y }
                    })
                end
            end
        end
        if #candidates > 0 then
            local pick = candidates[ math.random(1, #candidates) ]
            local lookCFrame = CFrame.new(Player.Character.PrimaryPart.Position, pick.character.PrimaryPart.Position)
            return {0, lookCFrame, events, pick.screenXY}
        else
            return {0, camera.CFrame, events, { camera.ViewportSize.X/2, camera.ViewportSize.Y/2 }}
        end
    end
    return parryType
end

-- Modified AutoParry.ExecuteParry to include firstParryFired logic
function AutoParry.ExecuteParry(parryType)
    local parryData = AutoParry.GetParryData(parryType)
    if not State.firstParryFired then
        performFirstPress(State.firstParryType)
        State.firstParryFired = true
    else
        if State.activeMethod == "Remote" then
            for remote, args in pairs(State.remotes) do
                remote:FireServer(args, State.parryKey, parryData[1], parryData[2], parryData[3], parryData[4])
            end
        else
            game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.F, false, nil)
        end
    end

    if State.parries > 7 then
        return false
    end
    State.parries = State.parries + 1
    task.delay(0.5, function()
        if State.parries > 0 then
            State.parries = State.parries - 1
        end
    end)
end

-- Functions for Cooldown Protection and Auto Ability (from second script, adapted)
local function isCooldownInEffect1(uigradient)
    return uigradient.Offset.Y < 0.4
end

local function isCooldownInEffect2(uigradient)
    return uigradient.Offset.Y == 0.5
end

local function cooldownProtection()
    local ParryCD = Player.PlayerGui.Hotbar.Block.UIGradient
    if isCooldownInEffect1(ParryCD) then
        game:GetService("ReplicatedStorage").Remotes.AbilityButtonPress:Fire()
        return true
    end
    return false
end

local function AutoAbility()
    local AbilityCD = Player.PlayerGui.Hotbar.Ability.UIGradient
    if isCooldownInEffect2(AbilityCD) then
        if Player.Character and Player.Character:FindFirstChild("Abilities") then
            if Player.Character.Abilities:FindFirstChild("Raging Deflection") and Player.Character.Abilities["Raging Deflection"].Enabled or
               Player.Character.Abilities:FindFirstChild("Rapture") and Player.Character.Abilities["Rapture"].Enabled or
               Player.Character.Abilities:FindFirstChild("Calming Deflection") and Player.Character.Abilities["Calming Deflection"].Enabled or
               Player.Character.Abilities:FindFirstChild("Aerodynamic Slash") and Player.Character.Abilities["Aerodynamic Slash"].Enabled or
               Player.Character.Abilities:FindFirstChild("Fracture") and Player.Character.Abilities["Fracture"].Enabled or
               Player.Character.Abilities:FindFirstChild("Death Slash") and Player.Character.Abilities["Death Slash"].Enabled then
                State.parried = true
                game:GetService("ReplicatedStorage").Remotes.AbilityButtonPress:Fire()
                task.wait(2.432)
                game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("DeathSlashShootActivation"):FireServer(true)
                return true
            end
        end
    end
    return false
end

local function ConnectAutoParry()
    State.connections['Auto Parry'] = RunService.PreSimulation:Connect(function()
        local balls = AutoParry.GetBalls()

        for _, ball in pairs(balls) do
            if not ball then continue end

            local zoomies = ball:FindFirstChild('zoomies')
            if not zoomies then continue end

            ball:GetAttributeChangedSignal('target'):Once(function()
                State.parried = false
            end)

            if State.parried then continue end

            local ballTarget = ball:GetAttribute('target')
            local velocity = zoomies.VectorVelocity
            local distance = (Player.Character.PrimaryPart.Position - ball.Position).Magnitude
            local speed = velocity.Magnitude
            local ping = game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue() / 10

            local cappedSpeedDiff = math.min(math.max(speed - 9.5, 0), 650)
            local speedDivisorBase = 2.4 + cappedSpeedDiff * 0.002
            local effectiveMultiplier = Config.SpeedMultiplier

            if Config.RandomParryAccuracyEnabled then
                if speed < 200 then
                    effectiveMultiplier = 0.7 + (math.random(40, 100) - 1) * (0.35 / 99)
                else
                    effectiveMultiplier = 0.7 + (math.random(1, 100) - 1) * (0.35 / 99)
                end
            end

            local speedDivisor = speedDivisorBase * effectiveMultiplier
            local parryAccuracy = math.clamp(ping / 10, 5, 17) + math.max(speed / speedDivisor, 9.5)
            local curved = AutoParry.IsCurved()

            if ball:FindFirstChild('AeroDynamicSlashVFX') then
                Debris:AddItem(ball.AeroDynamicSlashVFX, 0)
                State.aerodynamicTime = tick()
                State.aerodynamic = true
            end

            local runtime = workspace:FindFirstChild('Runtime')
            if runtime and runtime:FindFirstChild('Tornado') then
                local tornadoTime = runtime.Tornado:GetAttribute("TornadoTime") or 1
                if (tick() - State.aerodynamicTime) < tornadoTime + 0.314159 then
                    continue
                end
            end

            if ballTarget == tostring(Player) and curved then continue end
            if ball:FindFirstChild("ComboCounter") then continue end
            if Player.Character.PrimaryPart:FindFirstChild('SingularityCape') then continue end
            if Config.InfinityDetection and State.infinity then continue end
            if Config.DeathSlashDetection and State.deathSlash then continue end
            if Config.TimeHoleDetection and State.timeHole then continue end

            if ballTarget == tostring(Player) and distance <= parryAccuracy then
                if Config.AutoAbility and AutoAbility() then
                    return
                end
            end

            if ballTarget == tostring(Player) and distance <= parryAccuracy then
                if Config.CooldownProtection and cooldownProtection() then
                    return
                end
                local parryTime = os.clock()
                local timeView = parryTime - State.lastParry

                if timeView > 0.5 then
                    AutoParry.PlayParryAnimation()
                end

                if Config.AutoParryKeypress then
                    game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.F, false, nil)
                else
                    AutoParry.ExecuteParry(Config.ParryType)
                end

                State.lastParry = parryTime
                State.parried = true

                local lastParrys = tick()
                repeat
                    RunService.PreSimulation:Wait()
                until (tick() - lastParrys) >= 1 or not State.parried
                State.parried = false
            end
        end
    end)
end

local function ConnectAutoSpam()
    State.connections['Auto Spam'] = RunService.PreSimulation:Connect(function()
        local currentTime = tick()
        if currentTime - State.lastSpamCheck < State.spamCooldown then
            return
        end
        State.lastSpamCheck = currentTime

        local ball = AutoParry.GetBall()
        if not ball then return end

        local zoomies = ball:FindFirstChild('zoomies')
        if not zoomies then return end

        AutoParry.GetClosestPlayer()

        local ping = game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue()
        local pingThreshold = math.clamp(ping / 10, 1, 16) -- Adjusted threshold from second script
        local ballTarget = ball:GetAttribute('target')
        local distance = Player:DistanceFromCharacter(ball.Position)
        local targetDistance = State.closestEntity and Player:DistanceFromCharacter(State.closestEntity.PrimaryPart.Position) or math.huge

        -- New spam accuracy calculation
        local ballProperties = AutoParry:GetBallProperties()
        local entityProperties = AutoParry:GetEntityProperties()
        local spamAccuracy = AutoParry.SpamService({
            Ball_Properties = ballProperties,
            Entity_Properties = entityProperties,
            Ping = pingThreshold
        })

        if not ballTarget then
            return
        end
        if targetDistance > spamAccuracy or distance > spamAccuracy then
            return
        end

        local pulsed = Player.Character:GetAttribute('Pulsed')
        if pulsed then return end

        if ballTarget == tostring(Player) and targetDistance > 30 and distance > 30 then
            return
        end

        if distance <= spamAccuracy and State.parries > Config.ParryThreshold then
            if Config.SpamParryKeypress then
                game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.F, false, game)
            else
                AutoParry.ExecuteParry(Config.ParryType)
            end

            State.spamCooldown = math.random(8, 15) / 100
        end
    end)
end

local function ConnectLobbyAP()
    State.connections['Lobby AP'] = RunService.Heartbeat:Connect(function()
        local ball = AutoParry.GetLobbyBalls()
        if not ball then return end

        local zoomies = ball:FindFirstChild('zoomies')
        if not zoomies then return end

        ball:GetAttributeChangedSignal('target'):Once(function()
            State.trainingParried = false
        end)

        if State.trainingParried then return end

        local ballTarget = ball:GetAttribute('target')
        local velocity = zoomies.VectorVelocity
        local distance = Player:DistanceFromCharacter(ball.Position)
        local speed = velocity.Magnitude
        local ping = game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue() / 10

        local cappedSpeedDiff = math.min(math.max(speed - 9.5, 0), 650)
        local speedDivisorBase = 2.4 + cappedSpeedDiff * 0.002
        local effectiveMultiplier = Config.LobbySpeedMultiplier

        if Config.LobbyAPRandomParryAccuracyEnabled then
            effectiveMultiplier = 0.7 + (math.random(1, 100) - 1) * (0.35 / 99)
        end

        local speedDivisor = speedDivisorBase * effectiveMultiplier
        local parryAccuracy = ping + math.max(speed / speedDivisor, 9.5)

        if ballTarget == tostring(Player) and distance <= parryAccuracy then
            if Config.LobbyAPKeypress then
                game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.F, false, game)
            else
                AutoParry.ExecuteParry(Config.ParryType)
            end
            State.trainingParried = true

            local lastParrys = tick()
            repeat
                RunService.PreSimulation:Wait()
            until (tick() - lastParrys) >= 1 or not State.trainingParried
            State.trainingParried = false
        end
    end)
end

ReplicatedStorage.Remotes.InfinityBall.OnClientEvent:Connect(function(_, enabled)
    State.infinity = enabled
end)

-- DeathSlash detection from second script, adapted to use State.deathSlash
ReplicatedStorage.Remotes.DeathBall.OnClientEvent:Connect(function(_, enabled)
    State.deathSlash = enabled
end)

-- TimeHole detection from second script, adapted to use State.timeHole
ReplicatedStorage.Remotes.TimeHoleHoldBall.OnClientEvent:Connect(function(_, enabled)
    State.timeHole = enabled
end)

workspace.Balls.ChildAdded:Connect(function(ball)
    ball.ChildAdded:Connect(function(child)
        if Config.SlashOfFuryDetection and child.Name == 'ComboCounter' then
            local sofLabel = child:FindFirstChildOfClass('TextLabel')
            if sofLabel then
                repeat
                    local slashesCounter = tonumber(sofLabel.Text)
                    if slashesCounter and slashesCounter < 32 then
                        AutoParry.ExecuteParry(Config.ParryType)
                    end
                    task.wait()
                until not sofLabel.Parent or not sofLabel
            end
        end
    end)
end)

workspace.Runtime.ChildAdded:Connect(function(object)
    if Config.PhantomV2Detection and (object.Name == "maxTransmission" or object.Name == "transmissionpart") then
        local weld = object:FindFirstChildWhichIsA("WeldConstraint")
        if weld and weld.Part1 == Player.Character.HumanoidRootPart then
            State.currentBall = AutoParry.GetBall()
            weld:Destroy()
            if State.currentBall then
                local focusConnection = RunService.RenderStepped:Connect(function()
                    local highlighted = State.currentBall:GetAttribute("highlighted")
                    if highlighted == true then
                        Player.Character.Humanoid.WalkSpeed = 36
                        local humanoidRootPart = Player.Character:FindFirstChild("HumanoidRootPart")
                        if humanoidRootPart then
                            local playerToBall = (State.currentBall.Position - humanoidRootPart.Position).Unit
                            Player.Character.Humanoid:Move(playerToBall, false)
                        end
                    elseif highlighted == false then
                        focusConnection:Disconnect()
                        Player.Character.Humanoid.WalkSpeed = 10
                        Player.Character.Humanoid:Move(Vector3.new(0, 0, 0), false)
                        task.delay(3, function()
                            Player.Character.Humanoid.WalkSpeed = 36
                        end)
                        State.currentBall = nil
                    end
                end)
                task.delay(3, function()
                    if focusConnection and focusConnection.Connected then
                        focusConnection:Disconnect()
                        Player.Character.Humanoid:Move(Vector3.new(0, 0, 0), false)
                        Player.Character.Humanoid.WalkSpeed = 36
                        State.currentBall = nil
                    end
                end)
            end
        end
    elseif object.Name == 'Tornado' then
        State.aerodynamicTime = tick()
        State.aerodynamic = true
    end
end)

workspace.Balls.ChildRemoved:Connect(function()
    State.parries = 0
    State.parried = false
end)

-- ParrySuccessAll and ParrySuccess connections from second script, adapted to use State.grabParry
ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(_, root)
    if root.Parent and root.Parent ~= Player.Character then
        if root.Parent.Parent ~= workspace.Alive then
            return
        end
    end
    AutoParry.GetClosestPlayer()
    local ball = AutoParry.GetBall()
    if not ball then
        return
    end
    local targetDistance = (Player.Character.PrimaryPart.Position - State.closestEntity.PrimaryPart.Position).Magnitude
    local distance = (Player.Character.PrimaryPart.Position - ball.Position).Magnitude
    local direction = (Player.Character.PrimaryPart.Position - ball.Position).Unit
    local dot = direction:Dot(ball.AssemblyLinearVelocity.Unit)
    local curveDetected = AutoParry.IsCurved()
    if targetDistance < 15 and distance < 15 and dot > -0.25 then
        if curveDetected then
            AutoParry.ExecuteParry(Config.ParryType)
        end
    end
    if State.grabParry then
        State.grabParry:Stop()
    end
end)

ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(function()
    if Player.Character.Parent ~= workspace.Alive then
        return
    end
    if State.grabParry then
        State.grabParry:Stop()
    end
end)


local print = function() end

if getgenv().updateSword and getgenv().skinChanger then
    getgenv().updateSword()
    return
end

local function getTable(t:tableInfo)
    t = t or {}
    local tables = {}
    
    local function findMatches()
        for i,v in getgc(true) do
            if type(v) == "table" then
                local match = true
                if t.highEntropyTableIndex and (not rawget(v,t.highEntropyTableIndex)) then
                    match = false
                end
                if match then
                    table.insert(tables,v)
                end
            end
        end
    end

    findMatches()

    if #tables == 0 then
        while task.wait(1) and #tables == 0 do
            findMatches()
        end
    end

    if #tables == 1 then
        return tables[1]
    end
end

local plrs = game:GetService("Players")
local plr = plrs.LocalPlayer
local rs = game:GetService("ReplicatedStorage")
local swordInstancesInstance = rs:WaitForChild("Shared",9e9):WaitForChild("ReplicatedInstances",9e9):WaitForChild("Swords",9e9)
local swordInstances = require(swordInstancesInstance)

local swordsController

while task.wait() and (not swordsController) do
    for i,v in getconnections(rs.Remotes.FireSwordInfo.OnClientEvent) do
        if v.Function and islclosure(v.Function) then
            local upvalues = getupvalues(v.Function)
            if #upvalues == 1 and type(upvalues[1]) == "table" then
                swordsController = upvalues[1]
                break
            end
        end
    end
end

function getSlashName(swordName)
    local slashName = swordInstances:GetSword(swordName)
    return (slashName and slashName.SlashName) or "SlashEffect"
end

function setSword()
    if not getgenv().skinChanger then return end
    
    setupvalue(rawget(swordInstances,"EquipSwordTo"),2,false)
    
    swordInstances:EquipSwordTo(plr.Character, getgenv().swordModel)
    swordsController:SetSword(getgenv().swordAnimations)
end

local playParryFunc
local parrySuccessAllConnection

while task.wait() and not parrySuccessAllConnection do
    for i,v in getconnections(rs.Remotes.ParrySuccessAll.OnClientEvent) do
        if v.Function and getinfo(v.Function).name == "parrySuccessAll" then
            parrySuccessAllConnection = v
            playParryFunc = v.Function
            v:Disable()
        end
    end
end

local parrySuccessClientConnection
while task.wait() and not parrySuccessClientConnection do
    for i,v in getconnections(rs.Remotes.ParrySuccessClient.Event) do
        if v.Function and getinfo(v.Function).name == "parrySuccessAll" then
            parrySuccessClientConnection = v
            v:Disable()
        end
    end
end

getgenv().slashName = getSlashName(getgenv().swordFX)

local lastOtherParryTimestamp = 0
local clashConnections = {}

rs.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(...)
    setthreadidentity(2)
    local args = {...}
    if tostring(args[4]) ~= plr.Name then
        lastOtherParryTimestamp = tick()
    elseif getgenv().skinChanger then
        args[1] = getgenv().slashName
        args[3] = getgenv().swordFX
    end
    return playParryFunc(unpack(args))
end)

table.insert(clashConnections, getconnections(rs.Remotes.ParrySuccessAll.OnClientEvent)[1])

getgenv().updateSword = function()
    getgenv().slashName = getSlashName(getgenv().swordFX)
    setSword()
end

task.spawn(function()
    while task.wait(1) do
        if getgenv().skinChanger then
            local char = plr.Character or plr.CharacterAdded:Wait()
            if plr:GetAttribute("CurrentlyEquippedSword") ~= getgenv().swordModel then
                setSword()
            end
            if char and (not char:FindFirstChild(getgenv().swordModel)) then
                setSword()
            end
            for _,v in (char and char:GetChildren()) or {} do
                if v:IsA("Model") and v.Name ~= getgenv().swordModel then
                    v:Destroy()
                end
                task.wait()
            end
        end
    end
end)

-- Ball ChildAdded/Removed for parried state (from second script, adapted)
workspace.Balls.ChildAdded:Connect(function()
    State.parried = false
end)

workspace.Balls.ChildRemoved:Connect(function(Value)
    State.parries = 0
    State.parried = false
end)


local combatTab = main:create_tab("Combat", "rbxassetid://76499042599127")
local utilityTab = main:create_tab("Utility", "rbxassetid://126017907477623")
local esclusiveTab = main:create_tab("Esclusive", "rbxassetid://132767639164726")

local autoParryModule = combatTab:create_module({
    title = "Auto Parry",
    flag = "AutoParry",
    description = "good ap",
    section = "left",
    callback = function(value)
        Config.AutoParry = value
        if Config.AutoParryNotify then
            if value then
                Library.SendNotification({
                    title = "Module Notification",
                    text = "Auto Parry has been turned ON",
                    duration = 3
                })
            else
                Library.SendNotification({
                    title = "Module Notification",
                    text = "Auto Parry has been turned OFF",
                    duration = 3
                })
            end
        end
        if value then
            ConnectAutoParry()
        else
            if State.connections['Auto Parry'] then
                State.connections['Auto Parry']:Disconnect()
                State.connections['Auto Parry'] = nil
            end
        end
    end
})

local parryTypeMap = {
    ["Custom"] = "Custom",
    ["Random"] = "Random",
    ["Backwards"] = "Backwards",
}

local parryTypeDropdown = autoParryModule:create_dropdown({
    title = "Type",
    flag = "ParryType",
    options = {"Custom", "Random", "Backwards"},
    multi_dropdown = false,
    maximum_options = 3,
    callback = function(value)
        Config.ParryType = parryTypeMap[value] or value
    end
})

-- Hotkey logic for Parry Type
local parryOptions = {
    [Enum.KeyCode.One] = "Custom",
    [Enum.KeyCode.Two] = "Random",
    [Enum.KeyCode.Three] = "Backwards",
}
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then
        return
    end
    if not Config.HotkeyParryType then
        return
    end
    local newType = parryOptions[input.KeyCode]
    if newType then
        Config.ParryType = parryTypeMap[newType] or newType
        parryTypeDropdown:update(newType)
        if Config.HotkeyParryTypeNotify then
            Library.SendNotification({
                title = "Module Notification",
                text = "Parry Type changed to " .. newType,
                duration = 3
            })
        end
    end
end)

autoParryModule:create_slider({
    title = "Accuracy",
    flag = "ParryAccuracy",
    maximum_value = 100,
    minimum_value = 0,
    value = 100,
    round_number = true,
    callback = function(value)
        Config.SpeedMultiplier = 0.7 + (value - 1) * (0.35 / 99)
    end
})

autoParryModule:create_checkbox({
    title = "auto ability (beta)",
    flag = "AutoAbility",
    callback = function(value: boolean)
        Config.AutoAbility = value
    end
})

local autoSpamModule = combatTab:create_module({
    title = "Auto Spam",
    flag = "AutoSpam",
    description = "Auto Spam",
    section = "right",
    callback = function(value)
        Config.AutoSpam = value
        if Config.AutoSpamNotify then
            if value then
                Library.SendNotification({
                    title = "ON",
                    text = "OM",
                    duration = 3
                })
            else
                Library.SendNotification({
                    title = "OFF",
                    text = "OFF",
                    duration = 3
                })
            end
        end
        if value then
            ConnectAutoSpam()
        else
            if State.connections['Auto Spam'] then
                State.connections['Auto Spam']:Disconnect()
                State.connections['Auto Spam'] = nil
            end
        end
    end
})

local lobbyAPModule = utilityTab:create_module({
    title = "Lobby Auto Parry",
    flag = "LobbyAP",
    description = "Ap in lobby",
    section = "left",
    callback = function(value)
        Config.LobbyAP = value
        if Config.LobbyAPNotify then
            if value then
                Library.SendNotification({
                    title = "on ",
                    text = "on",
                    duration = 3
                })
            else
                Library.SendNotification({
                    title = "off",
                    text = "off",
                    duration = 3
                })
            end
        end
        if value then
            ConnectLobbyAP()
        else
            if State.connections['Lobby AP'] then
                State.connections['Lobby AP']:Disconnect()
                State.connections['Lobby AP'] = nil
            end
        end
    end
})

lobbyAPModule:create_slider({
    title = 'Parry Accuracy',
    flag = 'Parry_Accuracy',
    maximum_value = 100,
    minimum_value = 1,
    value = 100,
    round_number = true,
    callback = function(value: number)
        Config.LobbySpeedMultiplier = 0.7 + (value - 1) * (0.35 / 99)
    end
})


local SkinChanger = esclusiveTab:create_module({
    title = 'Skin Changer',
    flag = 'SkinChanger',
    description = 'Skin Changer',
    section = 'left',
    callback = function(value: boolean)
        getgenv().skinChanger = value
        if value then
            getgenv().updateSword()
        end
    end
})

SkinChanger:change_state(false)

local skinchangertextbox = SkinChanger:create_textbox({
    title = "add name",
    placeholder = "put your skin name",
    flag = "SkinChangerTextbox",
    callback = function(text)
        getgenv().swordModel = text
        getgenv().swordAnimations = text
        getgenv().swordFX = text
        if getgenv().skinChanger then
            getgenv().updateSword()
        end
    end
})

main:load()